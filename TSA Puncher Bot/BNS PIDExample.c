#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// PIDExample.c
//
// Author: Justin Marple with Team BNS
// Contact: jmarple@umass.edu
// Date: 01/07/2015
//
// This example file shows how to use
// the PID Controller built into the
// BNS Library
//
// Dependencies:
//   BNSLib.h in previous directory
//
// ------------------------------------------------------------------------
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// The author can be contacted by email at jmarple@umass.edu
//
// ------------------------------------------------------------------------
#pragma config(Sensor, in6,    adjusterPot,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           puncherLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           midRight,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           adjuster,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           midLeft,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           puncherRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "..\BNSLib.h"

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.

	SensorValue[leftEnc] = 0;

	BNS();

	PID pid1;
  PIDInit(&pid1, 0.1, 0, 0.1); // Set P, I, and D constants

}
void forwardDrive(int power){
	motor[frontLeft]   = power;
	motor[midLeft]     = power;
	motor[backLeft]    = power;
	motor[frontRight]  = power;
	motor[midRight]    = power;
	motor[backRight]   = power;
}

void turnDrive(int power, bool leftTurn=true){
	if(leftTurn){
		motor[frontLeft]   = power * 1;
		motor[midLeft]     = power * 1;
		motor[backLeft]    = power * 1;
		motor[frontRight]  = power * -1;
		motor[midRight]    = power * -1;
		motor[backRight]   = power * -1;
	}else if(!leftTurn){
		motor[frontLeft]   = power * -1;
		motor[midLeft]     = power * -1;
		motor[backLeft]    = power * -1;
		motor[frontRight]  = power * 1;
		motor[midRight]    = power * 1;
		motor[backRight]   = power * 1;
	}
}

task autonomous()
{
  // Initialize the BNS Library
  BNS();

  // The PID controller that will be used
  // The basic usage of this PID controller is as following:
  //
  // PID pid1;
  // PIDInit(&pid1, PConstant, IConstant, DConstant);
  // float feedback = PIDCompute(&pid1, your_error);
  //
  PID pid1;
  PIDInit(&pid1, 1.0, 0.0, 0.0); // Set P, I, and D constants

  // Output instructions to view the PID response
  writeDebugStreamLine("*** Copy/paste all the results in the debug window to Excel and graph what the PID response looks like! ***");

  int targetDistance = 360;
  int currentDistance;

  // Loop through many times so we can graph
  //  the PID loop
  for(int i = 0; i < 200; i++)
  {
  	currentDistance= SensorValue[leftEnc];
    // This calculates how far off we are from the true value
    //  The PID will return a response that will hopefully minimize this error over time
    float pidResult = PIDCompute(&pid1, targetDistance - currentDistance);

    // Add pid to motor value
    forwardDrive(pidResult);

    // There is a bug in RobotC where if you print too fast,
    //   you might get weird characters at random
    delay(5);
  }
}

task usercontrol(){
	while(true){
		wait1Msec(20);
	}
}
